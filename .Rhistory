dataset_try <- cbind(x,y,z)
setwd("~/Work/UvA/Statsdesk ABS")
write.csv(dataset_try,"try_out mediation")
nreps <- 6000
n <- 10
# initiele omega:
omega <- rnorm(n*(n-1)/2,mean = .05, sd = .01)
omega <- matrix(omega,n,n)
omega[lower.tri(omega)] <- t(omega)[lower.tri(omega)]
diag(omega) <- 0
tau <- rep(0,n)
dat <- matrix(0, nrow = nreps, ncol = n)
omega_save <- list(nreps)
gibbs_entropy <- numeric(nreps)
beta <- numeric(nreps)
beta[1] <- .001
did_flip <- numeric(nreps)
X1 <- sample(c(-1,1),n,T)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
bm[bm==0] <- -1
# beta update:
zeta <- .001
little_i <- 10
i <- 2
for(i in 1:nreps) {
if (i > 1 & 1 < little_i+1) {
beta[i] <- (1-zeta)+beta[i]*zeta*(i+i*sum(did_flip[1:(i-1)]-beta[i]))
}
if(i > little_i+1) {
beta[i] <- (1-zeta)+beta[i]*zeta*(i+i*((sum(did_flip[(i-little_i):(i-1)])/little_i)-beta[i]))
}
g <- sample(1:n,1)
p <- p_flip(tau = tau, omega = omega, X = X1, g = g, beta = beta[i])
if (p > runif(1)) {
X1[g] <- X1[g]*-1
did_flip[i] <- 1
}
}
plot(beta)
plot(beta, type = "l")
#' Simulation 3
#'
nreps <- 6000
n <- 10
# initiele omega:
omega <- rnorm(n*(n-1)/2,mean = .05, sd = .01)
omega <- matrix(omega,n,n)
omega[lower.tri(omega)] <- t(omega)[lower.tri(omega)]
diag(omega) <- 0
tau <- rep(0,n)
dat <- matrix(0, nrow = nreps, ncol = n)
omega_save <- list(nreps)
gibbs_entropy <- numeric(nreps)
beta <- numeric(nreps)
beta[1] <- .001
Hebb <- T
did_flip <- numeric(nreps)
X1 <- sample(c(-1,1),n,T)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
bm[bm==0] <- -1
# beta update:
zeta <- .001
little_i <- 10
i <- 2
for(i in 1:nreps) {
if (i > 1 & 1 < little_i+1) { # updates beta for inital i's
beta[i] <- (1-zeta)+beta[i]*zeta*(i+i*sum(did_flip[1:(i-1)]-beta[i]))
}
if(i > little_i+1) { # updates beta for all i's
beta[i] <- (1-zeta)+beta[i]*zeta*(i+i*((sum(did_flip[(i-little_i):(i-1)])/little_i)-beta[i]))
}
g <- sample(1:n,1)
p <- p_flip(tau = tau, omega = omega, X = X1, g = g, beta = beta[i])
if (p > runif(1)) {
X1[g] <- X1[g]*-1
did_flip[i] <- 1
}
pi_bm <- probability_bm(omega = omega, tau = tau, n = n, beta = beta, bm = bm) # boltzmann probabilities
gibbs_entropy[i] <- entropyS(omega = omega, tau = tau, beta = beta, pi_bm = pi_bm, n = n)
if(Hebb) {
omega <- delta_om(omega = omega, X = X1) # delta_om returns delta omega and omega new
omega <- omega[[2]] # omega[[2]] returns the updated omega
omega_save[[i]] <- omega
}
dat[i,] <- X1
}
beta[i+1] <- (1-zeta)*beta[i]*zeta*(i+i*sum(did_flip[(i-10):(i-1)]-beta[i]))
library(myPackage)
p_flip <- function(tau, omega, X, g, beta = 1) {
X2 <- X
X2[g] <- -X2[g]
p_flip <- 1/(1+exp(beta*(energy(tau,omega,X2)-energy(tau,omega,X))))
#p_flip <- exp(-beta*(energy(tau,omega,X)-energy(tau,omega,X2)))
return(p_flip)
}
library(myPackage)
library(myPackage)
library(myPackage)
?LIMA_sim1
n <- 10
nreps = 5000
!is.numeric(n) | !is.numeric(nreps)
!is.numeric(n) | !is.numeric(nreps) | !is.numeric(tau)
omega[lower.tri(omega)]==t(omega)[upper.tri(omega)]
omega[lower.tri(omega)]==t(omega)[lower.tri(omega)]
diag(omega)!=0
all(diag(omega)!=0)
diag(omega)
omega[lower.tri(omega)]==t(omega)[lower.tri(omega)]
?all
diag(omega)==0
all(diag(omega)==0)
some_matrix <- matrix(0,3,3)
some_matrix[1,1] <- 1
some_matrix
diag(some_matrix)==0
all(diag(some_matrix)==0)
X1
!is.numeric(X1)
is.numeric(X1)
length(X1)!=n
#' Simulation 1
#'
#' This function resembles simulation 1 from the LIMA chapter. It generates data for nreps iterations, based on an initial configuration (X1). At each iteration, a random node is flipped with probability p_flip and omega is updated with Hebb's rule (if Hebb=T).
#'
#' @param n are the number of nodes
#' @param nreps are the number of iterations
#' @param tau a vector with thresholds
#' @param omega a (symmetric) matrix with edge weights (diag==0)
#' @param beta is the dependency parameter
#' @param X1 is the initial configuration of the network
#' @param Hebb apply Hebb's rule (logical)
#'
#' @export
LIMA_sim1 <- function(n = 10, nreps = 5000, tau, omega, beta, X1, Hebb = TRUE) {
if(!is.numeric(n) | !is.numeric(nreps) | !is.numeric(tau) | !is.numeric(X1) | length(X1)!=n) {
stop("You probably inserted a nonnumeric object that should be numeric")
}
if(omega[lower.tri(omega)]==t(omega)[lower.tri(omega)] | all(diag(omega)!=0) {
stop("Omega is not symmetrical")
}
omega_save <- list(nreps)
dat <- matrix(0,nrow = nreps, ncol = n)
did_flip <- numeric(nreps)
prog = dplyr::progress_estimated(nreps)
for(i in 1:nreps) {
g <- sample(1:n,1)
p <- p_flip(tau = tau,omega = omega,X = X1, g = g)
if (p < runif(1)) {
X1[g] <- X1[g]*-1
did_flip[i] <- 1
}
omega_save[[i]] <- omega
dat[i,] <- X1
if (Hebb) {
omega <- delta_om(omega = omega, X = X1) # delta_om returns delta omega and omega new
omega <- omega[[2]] # omega[[2]] returns the updated omega
}
prog$tick()$print()
}
omega_mean <- numeric(nreps)
for(i in 1:nreps) {
omega_mean[i] <- mean(omega_save[[i]])
}
output <- list("configurations" = dat, "omega's" = omega_save, "mean omega's" = omega_mean, "did flip?" = did_flip)
return(output)
}
omega[lower.tri(omega)]==t(omega)[lower.tri(omega)]
all(omega[lower.tri(omega)]==t(omega)[lower.tri(omega)])
all(diag(omega)!=0
all(diag(omega)!=0)
all(diag(omega)!=0)
library(myPackage)
library(myPackage)
LIMA_sim1(n = a)
LIMA_sim1(n = "a")
function(n = 10, nreps = 5000, tau = rep(.2,10), omega = matrix(0,10,10), beta = 1, X1 = sample(c(-1,1),10,T), Hebb = TRUE)
LIMA_sim1(n = 10, nreps = 5000, tau = rep(.2,10), omega = matrix(0,10,10), beta = 1, X1 = sample(c(-1,1),10,T), Hebb = TRUE)
LIMA_sim1(n = "ten", nreps = 5000, tau = rep(.2,10), omega = matrix(0,10,10), beta = 1, X1 = sample(c(-1,1),10,T), Hebb = TRUE)
library(myPackage)
library(myPackage)
?LIMA_sim1
delta_om <- function(omega,X,e = .001,lambda = .001) {
delta_om <- matrix(0,nrow(omega),ncol(omega))
for(i in 1:length(X)) {
for(j in 1:length(X)) {
delta_om[i,j] <- e*(1-abs(omega[i,j]))*X[i]*X[j]-(lambda*omega[i,j])
}
}
diag(delta_om) <- 0
omega_new <- omega+delta_om
diag(omega_new) <- 0
output <- list("delta omega" = delta_om, "omega new" = omega_new)
return(output)
}
delta_om <- function(omega,X,e = .001,lambda = .001) {
delta_om <- matrix(0,nrow(omega),ncol(omega))
for(i in 1:length(X)) {
for(j in 1:length(X)) {
delta_om[i,j] <- e*(1-abs(omega[i,j]))*X[i]*X[j]-(lambda*omega[i,j])
}
}
diag(delta_om) <- 0
omega_new <- omega+delta_om
diag(omega_new) <- 0
output <- list("delta omega" = delta_om, "omega new" = omega_new)
return(output)
}
delta_om1 <- function(omega,X,e = .001,l = .001) {
omega1 <- matrix(0,nrow = nrow(omega), ncol = ncol(omega))
for(i in 1:nrow(omega)) {
for(j in 1:nrow(omega)) {
omega1[i,j] <- omega[i,j]*(1-l)+e*(1-abs(omega[i,j]))*x[i]*x[j]
}
}
return(omega1)
}
omega
X1
delta_om(omega = omega, X = X1)
delta_om1(omega = omega, X = X1)
delta_om1 <- function(omega,X,e = .001,l = .001) {
omega1 <- matrix(0,nrow = nrow(omega), ncol = ncol(omega))
for(i in 1:nrow(omega)) {
for(j in 1:nrow(omega)) {
if(i!=j)
omega1[i,j] <- omega[i,j]*(1-l)+e*(1-abs(omega[i,j]))*x[i]*x[j]
}
}
return(omega1)
}
d1 <- delta_om(omega = omega,X = X1)
d2 <- delta_om1(omega = omega,X = X1)
d1$`omega new`==d2
d1$`omega new`
d2
delta_om <- function(omega,X,e = .001,lambda = .001) {
delta_om <- matrix(0,nrow(omega),ncol(omega))
for(i in 1:length(X)) {
for(j in 1:length(X)) {
if(i!=j) {
delta_om[i,j] <- e*(1-abs(omega[i,j]))*X[i]*X[j]-(lambda*omega[i,j])
}
}
}
diag(delta_om) <- 0
omega_new <- omega+delta_om
diag(omega_new) <- 0
output <- list("delta omega" = delta_om, "omega new" = omega_new)
return(output)
}
delta_om(omega = omega, X = X1)
delta_om <- function(omega,X,e = .001,lambda = .001) {
delta_om <- matrix(0,nrow(omega),ncol(omega))
for(i in 1:length(X)) {
for(j in 1:length(X)) {
if(i!=j) {
delta_om[i,j] <- e*(1-abs(omega[i,j]))*X[i]*X[j]-(lambda*omega[i,j])
}
}
}
#diag(delta_om) <- 0
omega_new <- omega+delta_om
diag(omega_new) <- 0
output <- list("delta omega" = delta_om, "omega new" = omega_new)
return(output)
}
delta_om(omega = omega, X = X1)
}
delta_t <- function(tau,X,e = .001,l = .001) {
delta_t <- numeric(length(tau))
for(i in 1:length(tau)) {
delta_t[i] <- e*(1-abs(tau[i]))*X[i]-lambda*tau[i]
}
tau_new <- tau+delta_t
return(tau_new)
}
tau
X
X1
delta_t(tau,X1)
delta_t <- function(tau,X,e = .001,l = .001) {
delta_t <- numeric(length(tau))
for(i in 1:length(tau)) {
delta_t[i] <- e*(1-abs(tau[i]))*X[i]-l*tau[i]
}
tau_new <- tau+delta_t
return(tau_new)
}
delta_t(tau,X1)
detla_t(tau = rep(-.2,10), X = X1)
delta_t(tau = rep(-.2,10), X = X1)
X1
probability_bm <- function(omega, tau, n, beta = 1) {
pi_bm <- rep(0, 2^n)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
for(i in 1:length(pi_bm)) {
pi_bm[i] <- exp(-beta*ham(tau = tau, omega = omega, X = bm[i,]))
}
sum_pi_bm <- sum(pi_bm)
pi_bm <- pi_bm/sum_pi_bm
return(pi_bm)
}
probability_bm <- function(omega, tau, n, beta = 1) {
pi_bm <- rep(0, 2^n)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
for(i in 1:length(pi_bm)) {
pi_bm[i] <- exp(-beta*ham(tau = tau, omega = omega, X = bm[i,]))
}
sum_pi_bm <- sum(pi_bm)
pi_bm <- pi_bm/sum_pi_bm
return(pi_bm)
}
Si <- rep(0,2^length(X))
entropyS <- function(omega, tau, X, beta = 1, pi_bm) {
Si <- rep(0,2^length(X))
Si <- -sum(pi_bm*log2(pi_bm))
#
# for(i in 1:length(Si)) {
#   Si[i] <- pi_bm[i]*log2(pi_bm[i])
# }
# gibbs_entropy <- -1*sum(Si)
return("gibbs entropy" = Si)
}
warnings()
warnings()
probability_bm <- function(omega, tau, n, beta = 1, bm) {
pi_bm <- rep(0, 2^n)
for(i in 1:length(pi_bm)) {
pi_bm[i] <- exp(-beta*ham(tau = tau, omega = omega, X = bm[i,]))
}
sum_pi_bm <- sum(pi_bm)
pi_bm <- pi_bm/sum_pi_bm
return(pi_bm)
}
bm
probability_bm(omega = omega, tau = tau, n = n, bm = bm)
nrow(bm)
library(myPackage)
getwd()
library(LearningIsingModel)
devtools::install_github("BenjiUvA/Learning_Ising_Model")
usethis::use_testthat()
library(testthat)
set.seed(42)
p <- 10
tau <- runif(p, -1, 1)
X <- matrix(runif(p))
omega <- stats::rWishart(1, p+1, diag(p))
omega
omega <- stats::rWishart(1, p+1, diag(p))[, , 1]
omega
rnorm
set.seed(42)
p <- 10
tau <- runif(p, -1, 1)
X <- matrix(runif(p))
omega <- matrix(stats::rnorm(p^2), p, p)
omega <- tcrossprod(omega)
omega
diag(omega) <- 0
omega
omega
ham(tau = tau, X = X, omega = omega)
dput(ham(tau = tau, X = X, omega = omega))
?dput
structure(6.06721543218154, .Dim = c(1L, 1L))
expect_equal(
ham(tau = tau, X = X, omega = omega),
expected = structure(6.06721543218154, .Dim = c(1L, 1L))
)
TRUE | tdgftf
TRUE || tdgftf
FALSE && jyjyg
FALSE | c(TRUE, FALSE)
FALSE || c(TRUE, FALSE)
?`||`
probability_bm <- function(omega, tau, n, beta = 1, bm) {
pi_bm <- rep(0, 2^n)
for(i in 1:length(pi_bm)) {
pi_bm[i] <- exp(-beta*ham(tau = tau, omega = omega, X = bm[i,]))
}
sum_pi_bm <- sum(pi_bm)
pi_bm <- pi_bm/sum_pi_bm
return(pi_bm)
}
omega
probability_bm(omega = omega, tau = tau, n = 10, beta = 1, bm = as.matrix(expand.grid(rep(c(-1,1),n))))
tau
length(tau)
nrow(omega)
probability_bm(omega = omega, tau = tau, n = 10, beta = 1, bm = as.matrix(expand.grid(rep(c(-1,1),10))))
as.matrix(expand.grid(rep(c(-1,1),10)))
as.matrix(expand.grid(rep(list(0:1),10)))
as.matrix(expand.grid(rep(list(-1:1),10)))
bm <- as.matrix(expand.grid(rep(list(0:1),10)))
bm[bm==0] <- -1
probability_bm(omega = omega, tau = tau, n = 10, beta = 1, bm = bm)
outcome <- probability_bm(omega = omega, tau = tau, n = 10, beta = 1, bm = bm)
round(outcome,3)
round(outcome,4)
round(outcome,5)
outcome[-c(1:1000)]
outcome[1000]
outcome[999]
sum(outcome)
plot(outcome)
plot(outcome,type = "l")
which.max(outcome)
bm[524,]
tau
omega
tau <- rep(0.2,10)
omega <- matrix(0,10,10)
outcome <- probability_bm(omega = omega, tau = tau, n = 10, beta = 1, bm = bm)
outcome
sum(outcome)
beta_vec <- rep(c(seq(0,2,1/199.5),seq(2,0,-1/199.5),rep(0,400)),5)
nreps <- length(beta_vec)
n <- 10
# initiele omega:
omega <- rnorm(n*(n-1)/2,mean = .05, sd = .01)
omega <- matrix(omega,n,n)
omega[lower.tri(omega)] <- t(omega)[lower.tri(omega)]
diag(omega) <- 0
beta_vec <- rep(c(seq(0,2,1/199.5),seq(2,0,-1/199.5),rep(0,400)),5)
nreps <- length(beta_vec)
n <- 10
# initiele omega:
omega <- rnorm(n*(n-1)/2,mean = .05, sd = .01)
omega <- matrix(omega,n,n)
omega[lower.tri(omega)] <- t(omega)[lower.tri(omega)]
diag(omega) <- 0
# include this code to resemble an omega that updates itself from .05 to .17:
#  omega_fixed <- list(nreps) # to resemble the Hebbian updated omega in the chapter
#  omega_fixed_mean <- seq(.05,.17,(.17-.05)/(nreps-1))
#
# for(i in 1:nreps) {
#    omega_fixed[[i]] <- rnorm(n*(n-1)/2,mean = omega_fixed_mean[i], sd = .01)
#    omega_fixed[[i]] <- matrix(omega_fixed[[i]],n,n)
#    omega_fixed[[i]][lower.tri(omega_fixed[[i]])] <- t(omega_fixed[[i]])[lower.tri(omega_fixed[[i]])]
#    diag(omega_fixed[[i]]) <- 0
# }
Hebb <- T # want to simulate with(out) Hebbian learning?
tau <- rep(0,n)
dat <- matrix(0, nrow = nreps, ncol = n)
omega_save <- list(nreps)
gibbs_entropy <- numeric(nreps)
X1 <- rep(-1,n)
X1 <- sample(c(-1,1),n,T)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
bm[bm==0] <- -1
i <- 2
beta <- beta_vec[i]
beta
g <- sample(1:n,1)
g
X1
tau
omega
p <- p_flip(tau = tau, omega = omega, X = X1, g = g, beta = beta)
p
if (p > runif(1)) {
X1[g] <- X1[g]*-1
}
X1
pi_bm <- probability_bm(omega = omega, tau = tau, n = n, beta = beta, bm = bm) # boltzmann probabilities
gibbs_entropy[i] <- entropyS(omega = omega, tau = tau, beta = beta, pi_bm = pi_bm, n = n)
LIMA_sim2 <- function(n = 10, tau = rep(0,n)) {
}
LIMA_sim2 <- function(n = 10, tau = rep(0,n)) {
return(tau)
}
LIMA_sim2
LIMA_sim2()
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
bm[bm==0] <- -1
head(bm)
g <- sample(1:10,1)
g
LIMA_sim2 <- function(n = 10, tau = rep(0,n), omega = matrix(0,n,n), X = sample(c(-1,1),n,T), nreps = 6000, beta = 1, Hebb = T) {
dat <- matrix(0, nrow = nreps, ncol = n)
omega_save <- list(nreps)
gibbs_entropy <- numeric(nreps)
did_flip <- numeric(nreps)
bm <- as.matrix(expand.grid(rep(list(0:1),n)))
bm[bm==0] <- -1
X1 <- X
for (i in 1:nreps) {
beta_use <- beta[i]
omega_save[i] <- omega
dat[i,] <- X1
g <- sample(1:10,1)
p <- p_flip(tau = tau,omega = omega,X = X1,g = g,beta = beta_use)
if(p > runif(1)) {
X1[g] <- -X1[g]
did_flip[i] <- 1
}
pi_bm <- probability_bm(omega = omega,tau = tau,n = n,beta = beta_use,bm = bm)
gibbs_entropy[i] <- entropyS(omega = omega,tau = tau,X = X1,beta = beta_use,pi_bm = pi_bm)
omega <- delta_om(omega = omega,X = X1)
omega <- omega[[2]]
}
}
library(LearningIsingModel)
LIMA_sim2()
LIMA_sim2()
tau
omega
LIMA_sim2(n = 10,tau = tau, omega = omega, X,nreps = 6000, beta = 1,Hebb = T)
beta_use <- beta[i]
beta_use
